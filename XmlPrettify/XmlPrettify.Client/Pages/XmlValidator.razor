@page "/"
@using System.Xml
@using System.Xml.Linq
@using static System.Xml.Formatting
@using Radzen.Blazor
@using System.Text
@using System.Text.Json
@using System.Xml.Schema
@using XmlPrettify.Components.Models;
@rendermode InteractiveServer
@inject IJSRuntime JSRuntime
@inject Radzen.NotificationService NotificationService

<HeadContent>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8316836543955335"
            crossorigin="anonymous"></script>
</HeadContent>
<section>
    <h1 style="font-size:x-large; font-weight:bold; color: #004085;">XML Formatter and Validator</h1>
    <p style="color: #004085">Use this tool to validate and format your XML files easily. Simply paste your XML content or upload a file, select formatting options, and view the results instantly.</p>
    <hr style="border: none; border-top: 1px solid #111; margin: 1rem 0;" />

    <RadzenTemplateForm TItem="object">
        <div style="margin-bottom: 1rem;">
            <RadzenLabel Text="Input XML" />
            <div style="border: 1px solid #ccc; border-radius: 3px; padding: 3px; height: 300px;">
                <StandaloneCodeEditor @ref="codeEditor" OnKeyUp="KeyUpEventHandler" Id="code-editor" CssClass="my-editor-class" ConstructionOptions="EditorConstructionOptions" />
            </div>

        </div>

        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <div id="dragAndDropElement" style="border: 2px dashed #ccc; color: gray; border-radius: 4px; padding: 1rem; align-items:center; text-align: center; background-color: #f9f9f9; width: 100%;"
                 ondragover="event.preventDefault();"
                 ondrop="handleFileDrop(event)">
                <div id="fileInputContainer" style="width: 100%; align-content:center; align-items:center; text-align: center;">
                    <div id="fileInputContainerInstruction">
                        @DRAG_AND_DROP_INSTRUCTION_DEFAULT
                    </div>
                    <label for="input" class="input-label" >Select file</label>
                    <InputFile id="input" class="sr-only" OnChange="HandleFileSelected" />
                </div>
            </div>
        </div>

        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <div id="dragAndDropXsdElement" style="border: 2px dashed #ccc; color: gray; border-radius: 4px; padding: 1rem; align-items:center; text-align: center; background-color: #f9f9f9; width: 100%;"
                 ondragover="event.preventDefault();"
                 ondrop="handleXsdFileDrop(event)">
                <div id="xsdFileInputContainer" style="width: 100%; align-content:center; align-items:center; text-align: center;">
                    <div id="xsdFileInputContainerInstruction">
                        @DRAG_AND_DROP_XSD_INSTRUCTION_DEFAULT
                    </div>
                    <label for="input-xsd" class="input-label">Select file</label>
                    <InputFile id="input-xsd" class="sr-only" OnChange="HandleXsdFileSelected" />
                </div>
            </div>
        </div>

        @if (xmlSchema != null)
        {
            <div>@xmlSchemaFileName: Loaded</div>
            <RadzenButton Text="Clear XSD" Click="@ClearXmlSchema"></RadzenButton>
        }

        <hr style="border: none; border-top: 1px solid #ccc; margin: 1rem 0;" />
        <div style="display: flex; align-items: center; margin-bottom: 1rem;">
            <RadzenCheckBox @bind-Value="EnableFormattingOptions" Style="margin-right: 0.5rem;" />
            <label>Format XML</label>
        </div>
        
        @if (EnableFormattingOptions)
        {
            <div style="display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem;">
                <div style="display: flex; align-items: center;">
                    <RadzenCheckBox @bind-Value="PrettyPrint" Style="margin-right: 0.5rem;" />
                    <label>Pretty Print</label>
                </div>
                <div style="display: flex; align-items: center;">
                    <RadzenCheckBox @bind-Value="OmitXmlDeclaration" Style="margin-right: 0.5rem;" />
                    <label>Omit XML Declaration</label>
                </div>
                <div style="display: flex; align-items: center;">
                    <RadzenCheckBox @bind-Value="NewLineOnAttributes" Style="margin-right: 0.5rem;" />
                    <label>New Line on Attributes</label>
                </div>
            </div>
        }
        <hr style="border: none; border-top: 1px solid #ccc; margin: 1rem 0;" />

        <div style="display: flex; align-items: center;">
            <RadzenButton Text="@(EnableFormattingOptions ? "Validate and Format" : "Validate")" Click="@FormatXml" Style="margin-right: 1rem;" />
            <div id="validationNotification" style="opacity: 0; transition: opacity 0.5s; font-size: 0.9rem; color: green; margin-top: 0.5rem;">Valid XML!</div>
        </div>
        <div style="margin-top: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            <div style="flex-grow: 1;">

                <div>
                    <RadzenLabel Text="Output" />
                    <RadzenText @ref="ErrorDescriptionComponent" style="color: red" Text="@ErrorDescription"></RadzenText>
                </div>

                <RadzenTextArea @bind-Value="OutputXml" Rows="10" Disabled="true" Style="width: 100%; background-color: #f9f9f9; color: #000;" />
            </div>
            <RadzenButton Icon="content_copy" Tooltip="Copy to Clipboard" Click="CopyToClipboard" Style="padding: 0.5rem; font-size: 1rem;" />
        </div>
        <div id="copyNotification" style="opacity: 0; transition: opacity 0.5s; font-size: 0.9rem; color: green; margin-top: 0.5rem;">Copied to clipboard!</div>


    </RadzenTemplateForm>
    <script>
        window.setModelMarkers = function (editorInstance, errors) {
            monaco.editor.setModelMarkers(editorInstance.getModel(), "owner", errors);
        };
    </script>
</section>

@code {
    private bool isFileSelected = false;
    private IBrowserFile? selectedFile;
    private RadzenNotification? notification;

    private string inputXml = string.Empty;
    private string InputXml { get => inputXml; set { inputXml = value; codeEditor?.SetValue(InputXml); } }
    private string OutputXml { get; set; } = string.Empty;
    private bool EnableFormattingOptions { get; set; } = false;
    private bool PrettyPrint { get; set; } = true;
    private bool OmitXmlDeclaration { get; set; } = false;
    private bool NewLineOnAttributes { get; set; } = false;

    public const string DRAG_AND_DROP_XSD_INSTRUCTION_DEFAULT = "Drop your XSD file here if you want to use it for validation OR";

    public const string DRAG_AND_DROP_INSTRUCTION_DEFAULT = "Drop your XML file here OR";
    public const string DRAG_AND_DROP_INSTRUCTION_DRAGGED = "OK!";

    public string errorDescription = string.Empty;
    public string ErrorDescription { get { return errorDescription; } set { errorDescription = value; InvokeAsync(() => StateHasChanged()); } }

    private StandaloneCodeEditor? codeEditor;
    private DotNetObjectReference<XmlValidator>? objectReference;
    private RadzenText ErrorDescriptionComponent;

    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
            {
                AutomaticLayout = true,
                Language = "xml",
                Value = InputXml
            };
    }

    DelayedSingleAction validateSingleAction;

    protected override void OnInitialized()
    {
        objectReference = DotNetObjectReference.Create(this);
        codeEditor = new StandaloneCodeEditor();
        ErrorDescriptionComponent = new RadzenText();
        validateSingleAction = new DelayedSingleAction(async () => await ValidateXml(await codeEditor.GetValue()), 2000);
    }

    public void Dispose()
    {
        objectReference?.Dispose();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
            await JSRuntime.InvokeVoidAsync("registerDotNetObject", objectReference);
    }

    private List<MonacoValidationError> ValidationErrors { get; set; } = new List<MonacoValidationError>();

    private void ValidationErrorHandler(object sender, ValidationEventArgs e)
    {
        ValidationErrors.Add(new MonacoValidationError
            {
                Message = e.Message,
                StartLineNumber = e.Exception.LineNumber,
                StartColumn = e.Exception.LinePosition,
                EndLineNumber = e.Exception.LineNumber,
                EndColumn = e.Exception.LinePosition + 1
            });
    }

    private void KeyUpEventHandler(KeyboardEvent e)
    {
        validateSingleAction.PerformAction();
    }

    private async Task<(List<MonacoValidationError>?, XmlDocument?)> ValidateXml(string xml)
    {
        await ClearMarkersAndValidationErrors();

        if (string.IsNullOrWhiteSpace(xml))
        {
            ErrorDescription = "Input XML cannot be empty.";
            return (new List<MonacoValidationError>(), null);
        }

        var xmlDocument = new XmlDocument();

        try
        {
            var settings = new XmlReaderSettings();
            if (xmlSchema != null)
            {
                settings.Schemas.Add(xmlSchema);
                settings.ValidationType = ValidationType.Schema;
            }

            settings.ValidationEventHandler += (sender, e) => ValidationErrorHandler(sender, e);

            using var reader = XmlReader.Create(new StringReader(xml), settings);
            xmlDocument.Load(reader);

            if (ValidationErrors?.Any() ?? false)
            {
                await HighlightErrors(ValidationErrors);
                ShowInfoNotification("Invalid XML!", error: true);

                var errors = GetErrorsString(ValidationErrors);
                ErrorDescription = $"XML Validation Errors: {errors}";
            }

            return (ValidationErrors, xmlDocument);
        }
        catch (System.Xml.XmlException e)
        {
            ValidationErrors.Add(new MonacoValidationError
                {
                    Message = e.Message,
                    StartLineNumber = e.LineNumber,
                    StartColumn = e.LinePosition,
                    EndLineNumber = e.LineNumber,
                    EndColumn = e.LinePosition + 1
                });

            if (ValidationErrors?.Any() ?? false)
            {
                await HighlightErrors(ValidationErrors);
                ShowInfoNotification("Invalid XML!", error: true);

                var errors = GetErrorsString(ValidationErrors);
                ErrorDescription = $"XML Validation Errors: {errors}";
            }

            return (ValidationErrors, null);
        }
        catch (Exception ex)
        {
            return (null, null);
        }
    }

    private async Task FormatXml()
    {
        try
        {
            await ClearMarkersAndValidationErrors();

            InputXml = await codeEditor?.GetValue();

            if (string.IsNullOrWhiteSpace(InputXml))
            {
                ErrorDescription = "Input XML cannot be empty.";
                return;
            }

            var result = await ValidateXml(InputXml);
            var validationErrors = result.Item1;
            var xmlDocument = result.Item2;

            if (validationErrors?.Any() ?? false)
                return;

            if (xmlDocument == null)
            {
                ShowInfoNotification("Unhandled exception!", error: false);
                return;
            }

            ShowInfoNotification("Valid XML!", error: false);

            if (!EnableFormattingOptions)
            {
                OutputXml = InputXml;
                return;
            }
            else
            {
                var settings = new XmlWriterSettings
                    {
                        Indent = PrettyPrint,
                        IndentChars = "  ",
                        NewLineOnAttributes = NewLineOnAttributes,
                        OmitXmlDeclaration = OmitXmlDeclaration,
                        Encoding = new System.Text.UTF8Encoding(false)
                    };

                using (var stringWriter = new StringWriterWithEncoding(new System.Text.UTF8Encoding(false)))
                using (var xmlWriter = XmlWriter.Create(stringWriter, settings))
                {
                    xmlDocument.Save(xmlWriter);
                    OutputXml = stringWriter.ToString();
                }
            }

        }
        catch (XmlException ex)
        {
            ErrorDescription = $"XML Validation Error: {ex.Message}";
        }
        catch (Exception ex)
        {
            ErrorDescription = $"Error: {ex.Message}";
        }
    }

    private string GetErrorsString(List<MonacoValidationError> errors)
    {
        var stringBuilder = new StringBuilder();
        foreach (var error in errors)
            stringBuilder.AppendLine(error.Message);

        return stringBuilder.ToString();
    }

    private async Task HighlightErrors(List<MonacoValidationError> errors)
    {
        var markers = errors.Select(error => new MarkerData
            {
                Message = error.Message,
                Severity = MarkerSeverity.Error,
                StartLineNumber = error.StartLineNumber,
                StartColumn = error.StartColumn,
                EndLineNumber = error.EndLineNumber,
                EndColumn = error.EndColumn
            }).ToList();
        await BlazorMonaco.Editor.Global.SetModelMarkers(JSRuntime, await codeEditor?.GetModel(), "default", markers);
    }

    private async Task ClearMarkersAndValidationErrors()
    {
        await BlazorMonaco.Editor.Global.SetModelMarkers(JSRuntime, await codeEditor?.GetModel(), "default", new List<MarkerData>());
        ValidationErrors.Clear();
        ErrorDescription = string.Empty;
    }

    private async void CopyToClipboard()
    {
        await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", OutputXml);
        ShowCopyNotification();
    }

    private async void ShowCopyNotification()
    {
        await JSRuntime.InvokeVoidAsync("eval", "document.getElementById('copyNotification').style.opacity = '1'; setTimeout(() => document.getElementById('copyNotification').style.opacity = '0', 1500);");
    }

    private async void ShowPopup(string message)
    {
        await JSRuntime.InvokeVoidAsync("alert", message);
    }

    private async void ShowInfoNotification(string message, bool error)
    {
        if (error)
            await JSRuntime.InvokeVoidAsync("eval", "document.getElementById('validationNotification').style.color = 'red'; document.getElementById('validationNotification').textContent = 'Invalid XML!'; document.getElementById('validationNotification').style.opacity = '1'; setTimeout(() => document.getElementById('validationNotification').style.opacity = '0', 2000); ");
        else
            await JSRuntime.InvokeVoidAsync("eval", "document.getElementById('validationNotification').style.color = 'green'; document.getElementById('validationNotification').textContent = 'Valid XML!'; document.getElementById('validationNotification').style.opacity = '1'; setTimeout(() => document.getElementById('validationNotification').style.opacity = '0', 2000);");
    }

    public class StringWriterWithEncoding : StringWriter
    {
        private readonly Encoding _encoding;
        public StringWriterWithEncoding(Encoding encoding)
        {
            _encoding = encoding;
        }
        public override Encoding Encoding => _encoding;
    }

    [JSInvokable]
    public async Task HandleXsdFileDrop(string fileContents, string fileName)
    {
        try
        {
            await HandleXmlSchemaSet(fileContents, fileName);
            await JSRuntime.InvokeVoidAsync("eval", $"document.getElementById('xsdFileInputContainerInstruction').textContent = '{DRAG_AND_DROP_INSTRUCTION_DRAGGED}'; setTimeout(() => document.getElementById('xsdFileInputContainerInstruction').textContent = '{DRAG_AND_DROP_XSD_INSTRUCTION_DEFAULT}', 2000);");
            StateHasChanged();

        }
        catch (Exception ex)
        {
            NotificationService.Notify(new NotificationMessage
                {
                    Severity = NotificationSeverity.Error,
                    Summary = "Error",
                    Detail = $"Failed to read file: {ex.Message}"
                });
        }
    }

    [JSInvokable]
    public async Task HandleFileDrop(string fileContents, string fileName)
    {
        try
        {
            await codeEditor?.SetValue(fileContents);
            await JSRuntime.InvokeVoidAsync("eval", $"document.getElementById('fileInputContainerInstruction').textContent = '{DRAG_AND_DROP_INSTRUCTION_DRAGGED}'; setTimeout(() => document.getElementById('fileInputContainerInstruction').textContent = '{DRAG_AND_DROP_INSTRUCTION_DEFAULT}', 2000);");
            StateHasChanged();

        }
        catch (Exception ex)
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Error,
                Summary = "Error",
                Detail = $"Failed to read file: {ex.Message}"
            });
        }
    }

    private XmlSchema? xmlSchema;
    private string? xmlSchemaFileName;

    private async Task HandleXsdFileSelected(InputFileChangeEventArgs e)
    {
        if (e.File is not null)
        {
            try
            {
                var fileContentStream = new StreamContent(e.File.OpenReadStream());
                var fileContents = await fileContentStream.ReadAsStringAsync();
                var fileName = e.File.Name;
                await HandleXmlSchemaSet(fileContents, fileName);
            }
            catch (Exception ex)
            {
                NotificationService.Notify(new NotificationMessage
                    {
                        Severity = NotificationSeverity.Error,
                        Summary = "Error",
                        Detail = $"Exception: {ex.Message}"
                    });
            }
        }
    }

    private async Task HandleXmlSchemaSet(string fileContents, string fileName)
    {
        ClearXmlSchema();
        var byteArray = Encoding.ASCII.GetBytes(fileContents);
        MemoryStream stream = new MemoryStream(byteArray);

        var schema = XmlSchema.Read(stream, XsdValidationEventHandler);
        xmlSchema = schema;
        xmlSchemaFileName = fileName;
    }

    private void ClearXmlSchema()
    {
        xmlSchema = null;
        xmlSchemaFileName = null;
    }

    private void XsdValidationEventHandler(object sender, ValidationEventArgs e)
    {
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        if (e.File is not null)
        {
            try
            {
                var fileContentStream = new StreamContent(e.File.OpenReadStream());
                var fileContents = await fileContentStream.ReadAsStringAsync();
                await codeEditor?.SetValue(fileContents ?? string.Empty);
            }
            catch (Exception ex)
            {
                NotificationService.Notify(new NotificationMessage
                    {
                        Severity = NotificationSeverity.Error,
                        Summary = "Error",
                        Detail = $"Exception: {ex.Message}"
                    });
            }
        }
    }

    private class FileUpload
    {
        public Stream Stream { get; set; } = default!;
    }
    public class DelayedSingleAction
    {
        private readonly Action _action;
        private readonly long _millisecondsDelay;
        private long _syncValue = 1;
        public DelayedSingleAction(Action action, long millisecondsDelay)
        {
            _action = action;
            _millisecondsDelay = millisecondsDelay;
        }

        private Task _waitingTask = null;
        private void DoActionAndClearTask(Task _)
        {
            Interlocked.Exchange(ref _syncValue, 1);
            _action();
        }

        public void PerformAction()
        {
            if (Interlocked.Exchange(ref _syncValue, 0) == 1)
            {
                _waitingTask = Task.Delay(TimeSpan.FromMilliseconds(_millisecondsDelay))
                                   .ContinueWith(DoActionAndClearTask);
            }
        }

        public Task Complete()
        {
            return _waitingTask ?? Task.FromResult(0);
        }
    }
}